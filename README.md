# Конвейер обработки данных: Producer-Consumer с общей памятью

Этот проект представляет собой реализацию задачи "Производитель-Потребитель" на C++ для Linux. В проекте реализован конвейер для обработки бинарных данных (float) с использованием общей памяти (shared memory), многопоточности и сжатия данных.

Основная задача проекта — исследовать выигрыш в производительности от сжатия данных при их передаче через канал с ограниченной пропускной способностью (256-байтный кольцевой буфер).

## Ключевые возможности
*   **Межпроцессное взаимодействие (IPC):** Используется POSIX Shared Memory (`shm_open`, `mmap`) для создания общего канала данных между двумя независимыми процессами.
*   **Кольцевой буфер:** Реализован потокобезопасный кольцевой буфер для эффективной передачи данных в ограниченном объеме памяти.
*   **Многопоточное сжатие/распаковка:** Используется библиотека **ZSTD** для сжатия данных. Задачи по сжатию и распаковке распределяются между несколькими потоками для максимального использования ресурсов CPU.
*   **Фрагментация данных:** Реализован механизм, который автоматически разбивает сжатые блоки, превышающие размер буфера, на мелкие фрагменты и собирает их на принимающей стороне.
*   **Встроенный бенчмаркинг:** Программа имеет два режима работы (со сжатием и без) и выводит подробную статистику для оценки производительности, включая:
    *   Общее время выполнения конвейера.
    *   Коэффициент сжатия.
    *   Процент потерь данных (Data Loss).

## Структура проекта
```txt
.
├── CMakeLists.txt         # Файл для сборки проекта с помощью CMake
├── include/
│   └── ring_buffer.h      # Заголовочный файл для кольцевого буфера и общих структур
├── src/
│   ├── ring_buffer.cpp    # Реализация кольцевого буфера
│   ├── producer.cpp       # Исходный код "Производителя"
│   └── consumer.cpp       # Исходный код "Потребителя"
└── tests/
    └── test_floats.bin    # Пример входного файла (лежит в директории, однако можно создать свой)
```
## Установка и сборка
1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/lmkharitonov/cpp-shm-ringbuffer-pipeline
    cd cpp-shm-ringbuffer-pipeline
    ```

2.  **Установите зависимости (для Debian/Ubuntu):**
    ```bash
    sudo apt-get update
    sudo apt-get install build-essential cmake libzstd-dev
    ```

3.  **Соберите проект:**
    ```bash
    mkdir build
    cd build
    cmake ..
    make
    ```

## Использование и бенчмаркинг

Для объективной оценки производительности необходимо запустить конвейер в двух режимах.

#### Шаг 1: Запуск со сжатием

Откройте два терминала в директории `build`.

*   **Терминал 1 (Producer):**
    ```bash
    ./producer ../tests/test_floats.bin
    ```
*   **Терминал 2 (Consumer):**
    ```bash
    ./consumer ../tests/restored_compressed.bin
    ```
После завершения обе программы выведут свою статистику.

#### Шаг 2: Запуск без сжатия (базовый замер)

Снова откройте два терминала.

*   **Терминал 1 (Producer):**
    ```bash
    ./producer ../tests/test_floats.bin --nocompress
    ```
*   **Терминал 2 (Consumer):**
    ```bash
    ./consumer ../tests/restored_uncompressed.bin --nocompress
    ```
#### Шаг 3: Ручная проверка выходного файла

Команда не должна ничего выводить, если файлы полностью идентичны.

```bash
cmp ../tests/test_floats.bin ../tests/restored_compressed.bin
```

### Анализ результатов

Основным критерием успеха, согласно заданию, является производительность. Проведённые тестирования показали очевидное преимущество использования сжатия в вычислительном конвейере "Производитель-Потребитель" с ограниченной пропускной способностью канала.

1. **Время выполнения:**  
   В режиме без сжатия обработка 40 МБ данных занимает около 360 секунд у обоих процессов (producer и consumer). В режиме со сжатием объём передаваемых данных сокращается до 29.4 МБ, а время работы сокращается почти вдвое — до примерно 172 секунд. Это подтверждает, что затраты времени на сжатие и распаковку компенсируются сокращением времени передачи через узкий буфер размером 256 байт.

2. **Коэффициент сжатия:**  
   Коэффициент сжатия 73.41% означает, что передаваемые данные уменьшаются на 26.59%, что существенно снижает нагрузку на канал и повышает общую скорость обработки.

3. **Целостность данных:**  
   Потери данных отсутствуют (Data Loss = 0.0000%), что подтверждает корректность реализации фрагментации, передачи и сборки данных на стороне потребителя.

4. **Эффективность пропускной способности:**  
   Вычисленная пропускная способность для режима со сжатием выше почти в два раза по сравнению с режимом без сжатия, что свидетельствует о значительном улучшении производительности конвейера.
